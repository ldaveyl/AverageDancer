

# from mathutils import Vector


# def calculateAverage(armature):

#     # pose_bones = armature.pose.bones
#     bones = armature.pose.bones

#     for bone in bones:

#         print(bone.rotation_quaternion)
#         print(bone.name)

#         break

#     # bone_global_location = armature.matrix_world * 

#     return None

# pb.keyframe_insert("location", frame=23)

# pelvis location + rotation, de rest enkel rotation.


# Q is a Nx4 numpy matrix and contains the quaternions to average in the rows.
# The quaternions are arranged as (w,x,y,z), with w being the scalar
# The result will be the average quaternion of the input. Note that the signs
# of the output quaternion can be reversed, since q and -q describe the same orientation
def averageQuaternions(Q):
    # Number of quaternions to average
    M = Q.shape[0]
    A = np.zeros(shape=(4,4))

    for i in range(0,M):
        q = Q[i,:]
        # multiply q with its transposed version q' and add A
        A = np.outer(q,q) + A

    # scale
    A = (1.0/M)*A
    # compute eigenvalues and -vectors
    eigenValues, eigenVectors = np.linalg.eig(A)
    # Sort by largest eigenvalue
    eigenVectors = eigenVectors[:,eigenValues.argsort()[::-1]]
    # return the real part of the largest eigenvector (has only real part)
    return np.real(eigenVectors[:,0].A1)



# Dictionary of all armatures, and each key contains a new dictionary 
# armatures_dict = dict()

# for armature in armatures:
#     armatures_dict[armature.name] = {}

#     for frame_no in range(frame_start, frame_end):
#         bpy.context.scene.frame_set(frame_no)
#         armatures_dict[armature.name][frame_no] = []

#         print(armature.pose.bones)


#         break

# print(armatures_dict)


# # ---------------------
# # Global functions
# # ---------------------

# def list_armatures():
#     '''returns list of all armatures in the scene'''
#     global armatures_list
#     armatures_list = []
#     objects = bpy.context.scene.objects
#     for obj in objects: 
#         if obj.type == "ARMATURE":
#             armatures_list.append(obj)

# def armatures_enumarator(armatures):
#     return([(f'OP{i}', armature.name, "") for i, armature in enumerate(armatures)])

        # frame_start = bpy.context.scene.frame_start
        # frame_end = bpy.context.scene.frame_end

        # root_bones_lst = []
        # for armature in armatures_list:
        #     root_bones = self.find_root_bones(armature)


        
    # def find_root_bones(self, armature):
    #     root_bones = []
    #     for bone in armature.edit.bones:
    #         if not bone.parent:
    #             root_bones.append(bone)
    #     return root_bones

                    # root_bones_lst.append(root_bones)
        # frame_start = bpy.context.scene.frame_start
        # frame_end = bpy.context.scene.frame_end

        # for frame in range(frame_start, frame_end):
                    # bpy.context.scene.frame_set(frame)
